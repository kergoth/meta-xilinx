From 05f39b6ce04600d756825972b4b291faa6a0cb33 Mon Sep 17 00:00:00 2001
From: Yasir-Khan <yasir_khan@mentor.com>
Date: Sat, 19 Sep 2015 10:32:55 +0500
Subject: [PATCH] adi_axi_hdmi support

ADI AXI HDMI driver exposes the HDMI encoder into DRM and FB 
APIs. It is required to create a framebuffer device for video
display.

Signed-off-by: Yasir-Khan <yasir_khan@mentor.com>
---
 drivers/gpu/drm/Kconfig                         |    2 +
 drivers/gpu/drm/Makefile                        |    1 +
 drivers/gpu/drm/adi_axi_hdmi/Kconfig            |    7 +
 drivers/gpu/drm/adi_axi_hdmi/Makefile           |    7 +
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c    |  171 +++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h    |   18 +
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c     |  234 ++++++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h     |   49 ++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c |  542 +++++++++++++++++++++++
 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h |   15 +
 10 files changed, 1046 insertions(+)
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/Kconfig
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/Makefile
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
 create mode 100644 drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h

diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 66c716a..798ab62 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -210,3 +210,5 @@ source "drivers/gpu/drm/xylon/Kconfig"
 source "drivers/gpu/drm/amd/amdkfd/Kconfig"
 
 source "drivers/gpu/drm/imx/Kconfig"
+
+source "drivers/gpu/drm/adi_axi_hdmi/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 5ddc461..017d234 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -55,6 +55,7 @@ obj-$(CONFIG_DRM_GMA500) += gma500/
 obj-$(CONFIG_DRM_UDL) += udl/
 obj-$(CONFIG_DRM_AST) += ast/
 obj-$(CONFIG_DRM_ARMADA) += armada/
+obj-$(CONFIG_DRM_ADI_AXI_HDMI) += adi_axi_hdmi/
 obj-$(CONFIG_DRM_RCAR_DU) += rcar-du/
 obj-$(CONFIG_DRM_SHMOBILE) +=shmobile/
 obj-$(CONFIG_DRM_OMAP)	+= omapdrm/
diff --git a/drivers/gpu/drm/adi_axi_hdmi/Kconfig b/drivers/gpu/drm/adi_axi_hdmi/Kconfig
new file mode 100644
index 0000000..cf78722
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/Kconfig
@@ -0,0 +1,7 @@
+config DRM_ADI_AXI_HDMI
+	tristate "DRM Support for Analog Devices HDMI FPGA platforms"
+	depends on DRM
+	default	n
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select VT_HW_CONSOLE_BINDING if FRAMEBUFFER_CONSOLE
diff --git a/drivers/gpu/drm/adi_axi_hdmi/Makefile b/drivers/gpu/drm/adi_axi_hdmi/Makefile
new file mode 100644
index 0000000..5a889bd
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the drm device driver.  This driver provides support for the
+# Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
+
+adi_axi_hdmi-y := axi_hdmi_encoder.o axi_hdmi_crtc.o axi_hdmi_drv.o
+
+obj-$(CONFIG_DRM_ADI_AXI_HDMI) += adi_axi_hdmi.o
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
new file mode 100644
index 0000000..a3c04a9
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.c
@@ -0,0 +1,172 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/amba/xilinx_dma.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "axi_hdmi_crtc.h"
+#include "axi_hdmi_drv.h"
+#include "axi_hdmi_encoder.h"
+
+struct axi_hdmi_crtc {
+	struct drm_crtc drm_crtc;
+	struct dma_chan *dma;
+	struct xilinx_dma_config dma_config;
+	int mode;
+};
+
+static inline struct axi_hdmi_crtc *to_axi_hdmi_crtc(struct drm_crtc *crtc)
+{
+	return container_of(crtc, struct axi_hdmi_crtc, drm_crtc);
+}
+
+static int axi_hdmi_crtc_update(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+	struct drm_display_mode *mode = &crtc->mode;
+	struct drm_framebuffer *fb = crtc->primary->fb;
+	struct dma_async_tx_descriptor *desc;
+	struct drm_gem_cma_object *obj;
+	size_t offset;
+
+	if (!mode || !fb)
+		return -EINVAL;
+
+	dmaengine_terminate_all(axi_hdmi_crtc->dma);
+
+	if (axi_hdmi_crtc->mode == DRM_MODE_DPMS_ON) {
+		obj = drm_fb_cma_get_gem_obj(fb, 0);
+		if (!obj)
+			return -EINVAL;
+
+		axi_hdmi_crtc->dma_config.hsize = mode->hdisplay * fb->bits_per_pixel / 8;
+		axi_hdmi_crtc->dma_config.vsize = mode->vdisplay;
+		axi_hdmi_crtc->dma_config.stride = fb->pitches[0];
+
+		dmaengine_device_control(axi_hdmi_crtc->dma, DMA_SLAVE_CONFIG,
+			(unsigned long)&axi_hdmi_crtc->dma_config);
+
+		offset = crtc->x * fb->bits_per_pixel / 8 + crtc->y * fb->pitches[0];
+
+		desc = dmaengine_prep_slave_single(axi_hdmi_crtc->dma,
+					obj->paddr + offset,
+					mode->vdisplay * fb->pitches[0],
+					DMA_MEM_TO_DEV, 0);
+		if (!desc) {
+			pr_err("Failed to prepare DMA descriptor\n");
+			return -ENOMEM;
+		} else {
+			dmaengine_submit(desc);
+			dma_async_issue_pending(axi_hdmi_crtc->dma);
+		}
+	}
+
+	return 0;
+}
+
+static void axi_hdmi_crtc_dpms(struct drm_crtc *crtc, int mode)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	if (axi_hdmi_crtc->mode != mode) {
+		axi_hdmi_crtc->mode = mode;
+		axi_hdmi_crtc_update(crtc);
+	}
+}
+
+static void axi_hdmi_crtc_prepare(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	dmaengine_terminate_all(axi_hdmi_crtc->dma);
+}
+
+static void axi_hdmi_crtc_commit(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	axi_hdmi_crtc->mode = DRM_MODE_DPMS_ON;
+	axi_hdmi_crtc_update(crtc);
+}
+
+static bool axi_hdmi_crtc_mode_fixup(struct drm_crtc *crtc,
+	const struct drm_display_mode *mode,
+	struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static int axi_hdmi_crtc_mode_set(struct drm_crtc *crtc,
+	struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode,
+	int x, int y, struct drm_framebuffer *old_fb)
+{
+	/* We do everything in commit() */
+	return 0;
+}
+
+static int axi_hdmi_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
+	struct drm_framebuffer *old_fb)
+{
+	return axi_hdmi_crtc_update(crtc);
+}
+
+static void axi_hdmi_crtc_load_lut(struct drm_crtc *crtc)
+{
+}
+
+static struct drm_crtc_helper_funcs axi_hdmi_crtc_helper_funcs = {
+	.dpms		= axi_hdmi_crtc_dpms,
+	.prepare	= axi_hdmi_crtc_prepare,
+	.commit		= axi_hdmi_crtc_commit,
+	.mode_fixup	= axi_hdmi_crtc_mode_fixup,
+	.mode_set	= axi_hdmi_crtc_mode_set,
+	.mode_set_base	= axi_hdmi_crtc_mode_set_base,
+	.load_lut	= axi_hdmi_crtc_load_lut,
+};
+
+static void axi_hdmi_crtc_destroy(struct drm_crtc *crtc)
+{
+	struct axi_hdmi_crtc *axi_hdmi_crtc = to_axi_hdmi_crtc(crtc);
+
+	drm_crtc_cleanup(crtc);
+	kfree(axi_hdmi_crtc);
+}
+
+static struct drm_crtc_funcs axi_hdmi_crtc_funcs = {
+	.set_config	= drm_crtc_helper_set_config,
+	.destroy	= axi_hdmi_crtc_destroy,
+};
+
+struct drm_crtc *axi_hdmi_crtc_create(struct drm_device *dev)
+{
+	struct axi_hdmi_private *p = dev->dev_private;
+	struct axi_hdmi_crtc *axi_hdmi_crtc;
+	struct drm_crtc *crtc;
+
+	axi_hdmi_crtc = kzalloc(sizeof(*axi_hdmi_crtc), GFP_KERNEL);
+	if (!axi_hdmi_crtc) {
+		DRM_ERROR("failed to allocate axi_hdmi crtc\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	crtc = &axi_hdmi_crtc->drm_crtc;
+
+	axi_hdmi_crtc->dma = p->dma;
+
+	drm_crtc_init(dev, crtc, &axi_hdmi_crtc_funcs);
+	drm_crtc_helper_add(crtc, &axi_hdmi_crtc_helper_funcs);
+
+	return crtc;
+}
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h
new file mode 100644
index 0000000..583a721
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_crtc.h
@@ -0,0 +1,18 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _AXI_HDMI_CRTC_H_
+#define _AXI_HDMI_CRTC_H_
+
+struct drm_device;
+struct drm_crtc;
+
+struct drm_crtc* axi_hdmi_crtc_create(struct drm_device *dev);
+
+#endif
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
new file mode 100644
index 0000000..c676799
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.c
@@ -0,0 +1,234 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/of_address.h>
+#include <linux/of_dma.h>
+#include <linux/clk.h>
+
+#include <drm/drmP.h>
+#include <drm/drm.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "axi_hdmi_drv.h"
+#include "axi_hdmi_crtc.h"
+#include "axi_hdmi_encoder.h"
+
+#define DRIVER_NAME	"axi_hdmi_drm"
+#define DRIVER_DESC	"AXI HDMI DRM"
+#define DRIVER_DATE	"20120930"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+
+static void axi_hdmi_output_poll_changed(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+	drm_fbdev_cma_hotplug_event(private->fbdev);
+}
+
+static struct drm_mode_config_funcs axi_hdmi_mode_config_funcs = {
+	.fb_create = drm_fb_cma_create,
+	.output_poll_changed = axi_hdmi_output_poll_changed,
+};
+
+static void axi_hdmi_mode_config_init(struct drm_device *dev)
+{
+	dev->mode_config.min_width = 0;
+	dev->mode_config.min_height = 0;
+
+	dev->mode_config.max_width = 4096;
+	dev->mode_config.max_height = 4096;
+
+	dev->mode_config.funcs = &axi_hdmi_mode_config_funcs;
+}
+
+static int axi_hdmi_load(struct drm_device *dev, unsigned long flags)
+{
+	struct axi_hdmi_private *private = dev_get_drvdata(dev->dev);
+	struct drm_encoder *encoder;
+	int ret;
+
+	private->drm_dev = dev;
+
+	dev->dev_private = private;
+
+	drm_mode_config_init(dev);
+
+	/* init kms poll for handling hpd */
+	drm_kms_helper_poll_init(dev);
+
+	axi_hdmi_mode_config_init(dev);
+
+	private->crtc = axi_hdmi_crtc_create(dev);
+	if (IS_ERR(private->crtc)) {
+		ret = PTR_ERR(private->crtc);
+		goto err_crtc;
+	}
+
+	encoder = axi_hdmi_encoder_create(dev);
+	if (IS_ERR(encoder)) {
+	    ret = PTR_ERR(encoder);
+	    goto err_crtc;
+	}
+
+	private->fbdev = drm_fbdev_cma_init(dev, 32, 1, 1);
+	if (IS_ERR(private->fbdev)) {
+		DRM_ERROR("failed to initialize drm fbdev\n");
+		ret = PTR_ERR(private->fbdev);
+		goto err_crtc;
+	}
+
+	return 0;
+
+err_crtc:
+	drm_mode_config_cleanup(dev);
+	return ret;
+}
+
+static int axi_hdmi_unload(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+
+	drm_fbdev_cma_fini(private->fbdev);
+	drm_kms_helper_poll_fini(dev);
+	drm_mode_config_cleanup(dev);
+
+	return 0;
+}
+
+static void axi_hdmi_lastclose(struct drm_device *dev)
+{
+	struct axi_hdmi_private *private = dev->dev_private;
+	drm_fbdev_cma_restore_mode(private->fbdev);
+}
+
+static const struct file_operations axi_hdmi_driver_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.mmap		= drm_gem_cma_mmap,
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.unlocked_ioctl	= drm_ioctl,
+	.release	= drm_release,
+};
+
+static struct drm_driver axi_hdmi_driver = {
+	.driver_features	= DRIVER_MODESET | DRIVER_GEM,
+	.load			= axi_hdmi_load,
+	.unload			= axi_hdmi_unload,
+	.set_busid		= drm_platform_set_busid,
+	.lastclose		= axi_hdmi_lastclose,
+	.gem_free_object	= drm_gem_cma_free_object,
+	.gem_vm_ops		= &drm_gem_cma_vm_ops,
+	.dumb_create		= drm_gem_cma_dumb_create,
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,
+	.dumb_destroy		= drm_gem_dumb_destroy,
+	.fops			= &axi_hdmi_driver_fops,
+	.name			= DRIVER_NAME,
+	.desc			= DRIVER_DESC,
+	.date			= DRIVER_DATE,
+	.major			= DRIVER_MAJOR,
+	.minor			= DRIVER_MINOR,
+};
+
+static const struct of_device_id adv7511_encoder_of_match[] = {
+	{
+		.compatible = "adi,axi-hdmi-tx-1.00.a",
+		.data = (const void *)AXI_HDMI
+	}, {
+		.compatible = "adi,axi-hdmi-1.00.a",
+		.data = (const void *)AXI_HDMI_LEGACY
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, adv7511_encoder_of_match);
+
+static int axi_hdmi_platform_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *id;
+	struct device_node *np = pdev->dev.of_node;
+	struct axi_hdmi_private *private;
+	struct device_node *slave_node;
+	struct resource *res;
+
+	private = devm_kzalloc(&pdev->dev, sizeof(*private), GFP_KERNEL);
+	if (!private)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	private->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(private->base))
+		return PTR_ERR(private->base);
+
+	private->hdmi_clock = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(private->hdmi_clock)) {
+		printk("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
+		return -EPROBE_DEFER;
+	}
+
+	slave_node = of_parse_phandle(np, "encoder-slave", 0);
+	if (!slave_node)
+		return -EINVAL;
+
+	private->is_rgb = of_property_read_bool(np, "adi,is-rgb");
+
+	id = of_match_node(adv7511_encoder_of_match, np);
+	private->version = (unsigned long)id->data;
+
+	if (private->version == AXI_HDMI_LEGACY &&
+		of_property_read_bool(np, "adi,embedded-sync"))
+		private->version = AXI_HDMI_LEGACY_ES;
+	
+	private->encoder_slave = of_find_i2c_device_by_node(slave_node);
+	of_node_put(slave_node);
+
+	if (!private->encoder_slave || !private->encoder_slave->dev.driver) {
+		printk("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
+		return -EPROBE_DEFER;
+	}
+
+	private->dma = dma_request_slave_channel(&pdev->dev, "video");
+	if (private->dma == NULL) {
+		printk("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
+		return -EPROBE_DEFER;
+	}
+
+	platform_set_drvdata(pdev, private);
+
+	return drm_platform_init(&axi_hdmi_driver, pdev);
+}
+
+static int axi_hdmi_platform_remove(struct platform_device *pdev)
+{
+	struct axi_hdmi_private *private = platform_get_drvdata(pdev);
+
+	drm_put_dev(private->drm_dev);
+	dma_release_channel(private->dma);
+	return 0;
+}
+
+static struct platform_driver adv7511_encoder_driver = {
+	.driver = {
+		.name = "axi-hdmi",
+		.owner = THIS_MODULE,
+		.of_match_table = adv7511_encoder_of_match,
+	},
+	.probe = axi_hdmi_platform_probe,
+	.remove = axi_hdmi_platform_remove,
+};
+module_platform_driver(adv7511_encoder_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("");
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
new file mode 100644
index 0000000..544593c
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_drv.h
@@ -0,0 +1,49 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _AXI_HDMI_DRV_H_
+#define _AXI_HDMI_DRV_H_
+
+#include <drm/drm.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+
+struct xlnx_pcm_dma_params {
+	struct device_node *of_node;
+	int chan_id;
+};
+
+struct axi_hdmi_encoder;
+
+enum axi_hdmi_version {
+	AXI_HDMI,
+	AXI_HDMI_LEGACY,
+	AXI_HDMI_LEGACY_ES,
+};
+
+struct axi_hdmi_private {
+	struct drm_device *drm_dev;
+	struct drm_fbdev_cma *fbdev;
+	struct drm_crtc *crtc;
+	struct axi_hdmi_encoder *encoder;
+	struct i2c_client *encoder_slave;
+
+	void __iomem *base;
+
+	struct clk *hdmi_clock;
+	bool clk_enabled;
+
+	struct dma_chan *dma;
+
+	bool is_rgb;
+	enum axi_hdmi_version version;
+};
+
+#endif
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
new file mode 100644
index 0000000..d67e6df
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.c
@@ -0,0 +1,542 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/clk.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_encoder_slave.h>
+
+#include "axi_hdmi_drv.h"
+
+#include "../i2c/adv7511.h"
+
+#define AXI_HDMI_LEGACY_REG_CTRL		0x04
+#define AXI_HDMI_LEGACY_REG_HTIMING1		0x08
+#define AXI_HDMI_LEGACY_REG_HTIMING2		0x0C
+#define AXI_HDMI_LEGACY_REG_VTIMING1		0x10
+#define AXI_HDMI_LEGACY_REG_VTIMING2		0x14
+#define AXI_HDMI_LEGACY_REG_STATUS		0x10
+
+#define AXI_HDMI_LEGACY_ES_REG_HTIMING		0x08
+#define AXI_HDMI_LEGACY_ES_REG_VTIMING		0x0c
+
+#define AXI_HDMI_LEGACY_CTRL_ENABLE		BIT(0)
+
+#define AXI_HDMI_STATUS_VMDA_UNDERFLOW	BIT(4)
+#define AXI_HDMI_STATUS_VMDA_OVERFLOW	BIT(3)
+#define AXI_HDMI_STATUS_VMDA_BE_ERROR	BIT(2)
+#define AXI_HDMI_STATUS_VMDA_TPM_OOS	BIT(1)
+#define AXI_HDMI_STATUS_HDMI_TPM_OOS	BIT(0)
+
+#define AXI_HDMI_COLOR_PATTERN_ENABLE	BIT(24)
+
+#define AXI_HDMI_REG_RESET		0x040
+#define AXI_HDMI_REG_CTRL		0x044
+#define AXI_HDMI_REG_SOURCE_SEL		0x048
+#define AXI_HDMI_REG_COLORPATTERN	0x04c
+#define AXI_HDMI_REG_STATUS		0x05c
+#define AXI_HDMI_REG_VDMA_STATUS	0x060
+#define AXI_HDMI_REG_TPM_STATUS		0x064
+#define AXI_HDMI_REG_HTIMING1		0x400
+#define AXI_HDMI_REG_HTIMING2		0x404
+#define AXI_HDMI_REG_HTIMING3		0x408
+#define AXI_HDMI_REG_VTIMING1		0x440
+#define AXI_HDMI_REG_VTIMING2		0x444
+#define AXI_HDMI_REG_VTIMING3		0x448
+
+#define AXI_HDMI_RESET_ENABLE		BIT(0)
+
+#define AXI_HDMI_CTRL_FULL_RANGE	BIT(1)
+#define AXI_HDMI_CTRL_CSC_BYPASS	BIT(0)
+
+#define AXI_HDMI_SOURCE_SEL_COLORPATTERN	0x3
+#define AXI_HDMI_SOURCE_SEL_TESTPATTERN		0x2
+#define AXI_HDMI_SOURCE_SEL_NORMAL		0x1
+#define AXI_HDMI_SOURCE_SEL_NONE		0x0
+
+static const struct debugfs_reg32 axi_hdmi_encoder_debugfs_regs[] = {
+	{ "Reset", AXI_HDMI_REG_RESET },
+	{ "Control", AXI_HDMI_REG_CTRL },
+	{ "Source select", AXI_HDMI_REG_SOURCE_SEL },
+	{ "Colorpattern", AXI_HDMI_REG_COLORPATTERN },
+	{ "Status", AXI_HDMI_REG_STATUS },
+	{ "VDMA status", AXI_HDMI_REG_VDMA_STATUS },
+	{ "TPM status", AXI_HDMI_REG_TPM_STATUS },
+	{ "HTiming1", AXI_HDMI_REG_HTIMING1 },
+	{ "HTiming2", AXI_HDMI_REG_HTIMING2 },
+	{ "HTiming3", AXI_HDMI_REG_HTIMING3 },
+	{ "VTiming1", AXI_HDMI_REG_VTIMING1 },
+	{ "VTiming2", AXI_HDMI_REG_VTIMING2 },
+	{ "VTiming3", AXI_HDMI_REG_VTIMING3 },
+};
+
+static const uint16_t adv7511_csc_ycbcr_to_rgb[] = {
+	0x0734, 0x04ad, 0x0000, 0x1c1b,
+	0x1ddc, 0x04ad, 0x1f24, 0x0135,
+	0x0000, 0x04ad, 0x087c, 0x1b77,
+};
+
+struct axi_hdmi_encoder {
+	struct drm_encoder_slave encoder;
+	struct drm_connector connector;
+
+#ifdef CONFIG_DEBUG_FS
+	struct debugfs_regset32 regset;
+#endif
+};
+
+static inline struct axi_hdmi_encoder *to_axi_hdmi_encoder(struct drm_encoder *enc)
+{
+	return container_of(enc, struct axi_hdmi_encoder, encoder.base);
+}
+
+static inline struct drm_encoder *connector_to_encoder(struct drm_connector *connector)
+{
+	struct axi_hdmi_encoder *enc = container_of(connector, struct axi_hdmi_encoder, connector);
+	return &enc->encoder.base;
+}
+
+static int axi_hdmi_connector_init(struct drm_device *dev,
+	struct drm_connector *connector, struct drm_encoder *encoder);
+
+static inline struct drm_encoder_slave_funcs *
+get_slave_funcs(struct drm_encoder *enc)
+{
+	if (!to_encoder_slave(enc))
+		return NULL;
+
+	return to_encoder_slave(enc)->slave_funcs;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+static int axi_hdmi_debugfs_cp_get(void *data, u64 *val)
+{
+	struct axi_hdmi_private *private = data;
+	*val = readl(private->base + AXI_HDMI_REG_COLORPATTERN);
+	return 0;
+}
+
+static int axi_hdmi_debugfs_cp_set(void *data, u64 val)
+{
+	struct axi_hdmi_private *private = data;
+
+	writel(val, private->base + AXI_HDMI_REG_COLORPATTERN);
+
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(axi_hdmi_cp_fops, axi_hdmi_debugfs_cp_get,
+	axi_hdmi_debugfs_cp_set, "0x%06llx\n");
+
+static const char * const axi_hdmi_mode_text[] = {
+	[AXI_HDMI_SOURCE_SEL_NONE] = "none",
+	[AXI_HDMI_SOURCE_SEL_NORMAL] = "normal",
+	[AXI_HDMI_SOURCE_SEL_TESTPATTERN] = "testpattern",
+	[AXI_HDMI_SOURCE_SEL_COLORPATTERN] = "colorpattern",
+};
+
+static ssize_t axi_hdmi_read_mode(struct file *file, char __user *userbuf,
+	size_t count, loff_t *ppos)
+{
+	struct axi_hdmi_private *private = file->private_data;
+	uint32_t src;
+	const char *fmt;
+	size_t len = 0;
+	char buf[50];
+	int i;
+
+	src = readl(private->base + AXI_HDMI_REG_SOURCE_SEL);
+
+	for (i = 0; i < ARRAY_SIZE(axi_hdmi_mode_text); i++) {
+		if (src == i)
+			fmt = "[%s] ";
+		else
+			fmt = "%s ";
+		len += scnprintf(buf + len, sizeof(buf) - len, fmt,
+				axi_hdmi_mode_text[i]);
+	}
+
+	buf[len - 1] = '\n';
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, len);
+}
+
+static ssize_t axi_hdmi_set_mode(struct file *file, const char __user *userbuf,
+	size_t count, loff_t *ppos)
+{
+	struct axi_hdmi_private *private = file->private_data;
+	char buf[20];
+	unsigned int i;
+
+	count = min_t(size_t, count, sizeof(buf) - 1);
+	if (copy_from_user(buf, userbuf, count))
+		return -EFAULT;
+
+	buf[count] = '\0';
+
+	for (i = 0; i < ARRAY_SIZE(axi_hdmi_mode_text); i++) {
+		if (sysfs_streq(axi_hdmi_mode_text[i], buf))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(axi_hdmi_mode_text))
+		return -EINVAL;
+
+	writel(i, private->base + AXI_HDMI_REG_SOURCE_SEL);
+
+	return count;
+}
+
+static const struct file_operations axi_hdmi_mode_fops = {
+	.open = simple_open,
+	.read = axi_hdmi_read_mode,
+	.write = axi_hdmi_set_mode,
+};
+
+static void axi_hdmi_debugfs_init(struct axi_hdmi_encoder *encoder)
+{
+	struct axi_hdmi_private *priv = encoder->encoder.base.dev->dev_private;
+
+	if (priv->version != AXI_HDMI)
+		return;
+
+	encoder->regset.base = priv->base;
+	encoder->regset.regs = axi_hdmi_encoder_debugfs_regs;
+	encoder->regset.nregs = ARRAY_SIZE(axi_hdmi_encoder_debugfs_regs);
+
+	debugfs_create_regset32(dev_name(encoder->encoder.base.dev->dev), S_IRUGO, NULL, &encoder->regset);
+	debugfs_create_file("color_pattern", 0600, NULL, priv, &axi_hdmi_cp_fops);
+	debugfs_create_file("mode", 0600, NULL, priv, &axi_hdmi_mode_fops);
+}
+
+#else
+
+static inline void axi_hdmi_debugfs_init(struct axi_hdmi_encoder *enc)
+{
+}
+
+#endif
+
+static void axi_hdmi_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	struct axi_hdmi_encoder *axi_hdmi_encoder = to_axi_hdmi_encoder(encoder);
+	struct drm_connector *connector = &axi_hdmi_encoder->connector;
+	struct axi_hdmi_private *private = encoder->dev->dev_private;
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct adv7511_video_config config;
+	struct edid *edid;
+
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		if (!private->clk_enabled) {
+			clk_prepare_enable(private->hdmi_clock);
+			private->clk_enabled = true;
+		}
+		if (private->version == AXI_HDMI)
+			writel(AXI_HDMI_RESET_ENABLE, private->base + AXI_HDMI_REG_RESET);
+		else
+			writel(AXI_HDMI_LEGACY_CTRL_ENABLE, private->base + AXI_HDMI_LEGACY_REG_CTRL);
+		edid = adv7511_get_edid(encoder);
+		if (edid) {
+			config.hdmi_mode = drm_detect_hdmi_monitor(edid);
+			kfree(edid);
+		} else {
+			config.hdmi_mode = false;
+		}
+
+		hdmi_avi_infoframe_init(&config.avi_infoframe);
+
+		config.avi_infoframe.scan_mode = HDMI_SCAN_MODE_UNDERSCAN;
+
+		if (private->is_rgb) {
+				config.csc_enable = false;
+				config.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;
+		} else {
+			config.csc_scaling_factor = ADV7511_CSC_SCALING_4;
+			config.csc_coefficents = adv7511_csc_ycbcr_to_rgb;
+
+			if ((connector->display_info.color_formats & DRM_COLOR_FORMAT_YCRCB422) &&
+				config.hdmi_mode) {
+				config.csc_enable = false;
+				config.avi_infoframe.colorspace = HDMI_COLORSPACE_YUV422;
+			} else {
+				config.csc_enable = true;
+				config.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;
+			}
+		}
+
+		sfuncs->set_config(encoder, &config);
+		break;
+	default:
+		if (private->version == AXI_HDMI)
+			writel(0, private->base + AXI_HDMI_REG_RESET);
+		else
+			writel(0, private->base + AXI_HDMI_LEGACY_REG_CTRL);
+		if (private->clk_enabled) {
+			clk_disable_unprepare(private->hdmi_clock);
+			private->clk_enabled = false;
+		}
+		break;
+	}
+
+	if (sfuncs && sfuncs->dpms)
+		sfuncs->dpms(encoder, mode);
+}
+
+static bool axi_hdmi_encoder_mode_fixup(struct drm_encoder *encoder,
+	const struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode)
+{
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+
+	if (sfuncs && sfuncs->mode_fixup)
+		return sfuncs->mode_fixup(encoder, mode, adjusted_mode);
+
+	return true;
+}
+
+static void axi_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode, struct drm_display_mode *adjusted_mode)
+{
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct axi_hdmi_private *private = encoder->dev->dev_private;
+	unsigned int h_de_min, h_de_max;
+	unsigned int v_de_min, v_de_max;
+	unsigned int val;
+
+	if (sfuncs && sfuncs->mode_set)
+		sfuncs->mode_set(encoder, mode, adjusted_mode);
+
+	h_de_min = mode->htotal - mode->hsync_start;
+	h_de_max = h_de_min + mode->hdisplay;
+	v_de_min = mode->vtotal - mode->vsync_start;
+	v_de_max = v_de_min + mode->vdisplay;
+	
+	switch (private->version) {
+	case AXI_HDMI:
+		val = (mode->hdisplay << 16) | mode->htotal;
+		writel(val,  private->base + AXI_HDMI_REG_HTIMING1);
+		val = mode->hsync_end - mode->hsync_start;
+		writel(val,  private->base + AXI_HDMI_REG_HTIMING2);
+		val = (h_de_max << 16) | h_de_min;
+		writel(val,  private->base + AXI_HDMI_REG_HTIMING3);
+
+		val = (mode->vdisplay << 16) | mode->vtotal;
+		writel(val,  private->base + AXI_HDMI_REG_VTIMING1);
+		val = mode->vsync_end - mode->vsync_start;
+		writel(val,  private->base + AXI_HDMI_REG_VTIMING2);
+		val = (v_de_max << 16) | v_de_min;
+		writel(val,  private->base + AXI_HDMI_REG_VTIMING3);
+		break;
+	case AXI_HDMI_LEGACY_ES:
+		val = (mode->hdisplay << 16) | mode->htotal;
+		writel(val, private->base + AXI_HDMI_LEGACY_ES_REG_HTIMING);
+		val = (mode->vdisplay << 16) | mode->vtotal;
+		writel(val, private->base + AXI_HDMI_LEGACY_ES_REG_VTIMING);
+		break;
+	case AXI_HDMI_LEGACY:
+		val = (mode->hsync_end - mode->hsync_start) << 16 | mode->htotal;
+		writel(val, private->base + AXI_HDMI_LEGACY_REG_HTIMING1);
+		val = (h_de_min << 16) | h_de_max;
+		writel(val, private->base + AXI_HDMI_LEGACY_REG_HTIMING2);
+		val = (mode->vsync_end - mode->vsync_start) << 16 | mode->vtotal;
+		writel(val, private->base + AXI_HDMI_LEGACY_REG_VTIMING1);
+		val = (v_de_min << 16) | v_de_max;
+		writel(val, private->base + AXI_HDMI_LEGACY_REG_VTIMING2);
+		break;
+	default:
+		break;
+	}
+
+	clk_set_rate(private->hdmi_clock, mode->clock * 1000);
+}
+
+static void axi_hdmi_encoder_commit(struct drm_encoder *encoder)
+{
+	axi_hdmi_encoder_dpms(encoder, DRM_MODE_DPMS_ON);
+}
+
+static void axi_hdmi_encoder_prepare(struct drm_encoder *encoder)
+{
+	axi_hdmi_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);
+}
+
+static struct drm_crtc *axi_hdmi_encoder_get_crtc(struct drm_encoder *encoder)
+{
+	return encoder->crtc;
+}
+
+static struct drm_encoder_helper_funcs axi_hdmi_encoder_helper_funcs = {
+	.dpms		= axi_hdmi_encoder_dpms,
+	.mode_fixup	= axi_hdmi_encoder_mode_fixup,
+	.mode_set	= axi_hdmi_encoder_mode_set,
+	.prepare	= axi_hdmi_encoder_prepare,
+	.commit		= axi_hdmi_encoder_commit,
+	.get_crtc	= axi_hdmi_encoder_get_crtc,
+};
+
+static void axi_hdmi_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	struct axi_hdmi_encoder *axi_hdmi_encoder =
+		to_axi_hdmi_encoder(encoder);
+
+	if (sfuncs && sfuncs->destroy)
+		sfuncs->destroy(encoder);
+
+	drm_encoder_cleanup(encoder);
+	encoder->dev->mode_config.num_encoder--;
+	kfree(axi_hdmi_encoder);
+}
+
+static struct drm_encoder_funcs axi_hdmi_encoder_funcs = {
+	.destroy = axi_hdmi_encoder_destroy,
+};
+
+struct drm_encoder *axi_hdmi_encoder_create(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+	struct axi_hdmi_encoder *axi_hdmi_encoder;
+	struct drm_i2c_encoder_driver *encoder_drv;
+	struct axi_hdmi_private *priv = dev->dev_private;
+
+	axi_hdmi_encoder = kzalloc(sizeof(*axi_hdmi_encoder), GFP_KERNEL);
+	if (!axi_hdmi_encoder) {
+		DRM_ERROR("failed to allocate encoder\n");
+		return NULL;
+	}
+
+	encoder = &axi_hdmi_encoder->encoder.base;
+	encoder->possible_crtcs = 1;
+
+	drm_encoder_init(dev, encoder, &axi_hdmi_encoder_funcs,
+			DRM_MODE_ENCODER_TMDS);
+	drm_encoder_helper_add(encoder, &axi_hdmi_encoder_helper_funcs);
+
+	encoder_drv =
+	to_drm_i2c_encoder_driver(to_i2c_driver(priv->encoder_slave->dev.driver));
+	encoder_drv->encoder_init(priv->encoder_slave, dev,
+		&axi_hdmi_encoder->encoder);
+
+	connector = &axi_hdmi_encoder->connector;
+
+	axi_hdmi_connector_init(dev, connector, encoder);
+	axi_hdmi_debugfs_init(axi_hdmi_encoder);
+
+	if (priv->version == AXI_HDMI) {
+		writel(AXI_HDMI_SOURCE_SEL_NORMAL, priv->base + AXI_HDMI_REG_SOURCE_SEL);
+		if (priv->is_rgb)
+				writel(AXI_HDMI_CTRL_CSC_BYPASS, priv->base + AXI_HDMI_REG_CTRL);
+	}
+
+	return encoder;
+}
+
+static int axi_hdmi_connector_get_modes(struct drm_connector *connector)
+{
+	struct drm_encoder *encoder = connector_to_encoder(connector);
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+	int count = 0;
+
+	if (sfuncs && sfuncs->get_modes)
+		count += sfuncs->get_modes(encoder, connector);
+
+	return count;
+}
+
+static int axi_hdmi_connector_mode_valid(struct drm_connector *connector,
+	struct drm_display_mode *mode)
+{
+	if (mode->clock > 165000)
+		return MODE_CLOCK_HIGH;
+
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		return MODE_NO_INTERLACE;
+
+	return MODE_OK;
+}
+
+static struct drm_encoder *axi_hdmi_best_encoder(struct drm_connector *connector)
+{
+	return connector_to_encoder(connector);
+}
+
+static struct drm_connector_helper_funcs axi_hdmi_connector_helper_funcs = {
+	.get_modes	= axi_hdmi_connector_get_modes,
+	.mode_valid	= axi_hdmi_connector_mode_valid,
+	.best_encoder	= axi_hdmi_best_encoder,
+};
+
+static enum drm_connector_status axi_hdmi_connector_detect(
+	struct drm_connector *connector, bool force)
+{
+	enum drm_connector_status status = connector_status_unknown;
+	struct drm_encoder *encoder = connector_to_encoder(connector);
+	struct drm_encoder_slave_funcs *sfuncs = get_slave_funcs(encoder);
+
+	if (sfuncs && sfuncs->detect)
+		status = sfuncs->detect(encoder, connector);
+
+	return status;
+}
+
+static void axi_hdmi_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+static struct drm_connector_funcs axi_hdmi_connector_funcs = {
+	.dpms		= drm_helper_connector_dpms,
+	.fill_modes	= drm_helper_probe_single_connector_modes,
+	.detect		= axi_hdmi_connector_detect,
+	.destroy	= axi_hdmi_connector_destroy,
+};
+
+static int axi_hdmi_connector_init(struct drm_device *dev,
+	struct drm_connector *connector, struct drm_encoder *encoder)
+{
+	int type;
+	int err;
+
+	type = DRM_MODE_CONNECTOR_HDMIA;
+	connector->polled = DRM_CONNECTOR_POLL_CONNECT |
+				DRM_CONNECTOR_POLL_DISCONNECT;
+
+	drm_connector_init(dev, connector, &axi_hdmi_connector_funcs, type);
+	drm_connector_helper_add(connector, &axi_hdmi_connector_helper_funcs);
+
+	err = drm_connector_register(connector);
+	if (err)
+		goto err_connector;
+
+	connector->encoder = encoder;
+
+	err = drm_mode_connector_attach_encoder(connector, encoder);
+	if (err) {
+		DRM_ERROR("failed to attach a connector to a encoder\n");
+		goto err_sysfs;
+	}
+
+	return 0;
+
+err_sysfs:
+	drm_connector_unregister(connector);
+err_connector:
+	drm_connector_cleanup(connector);
+	return err;
+}
diff --git a/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h
new file mode 100644
index 0000000..0e951b5
--- /dev/null
+++ b/drivers/gpu/drm/adi_axi_hdmi/axi_hdmi_encoder.h
@@ -0,0 +1,15 @@
+/*
+ * Analog Devices AXI HDMI DRM driver.
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *  Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _AXI_HDMI_ENCODER_H_
+#define _AXI_HDMI_ENCODER_H_
+
+struct drm_encoder *axi_hdmi_encoder_create(struct drm_device *dev);
+
+#endif
-- 
1.7.9.5

